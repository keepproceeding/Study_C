#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define KEY_SIZE 10 // 탐색 키의 최대 길이
#define TABLE_SIZE 13 // 해싱 테이블의 크기 = 소수
#define empty(item) (strlen(item.key) == 0)
#define equal(item1, item2) (!strcmp(item1.key, item2.key))
#define _CRT_SECURE_NO_WARNINGS




//// 선형 조사법
//element hash_table[TABLE_SIZE];
//
//void init_table(element ht[]) {    // memset을 사용해도 됨
//	int i;
//	for (i = 0; i < TABLE_SIZE; i++) {
//		ht[i].key[0] = NULL;  // 궁금한 점 : 왜 0 index에만 초기화를 하는가? 
//	}
//}
//
//// 문자로 된 키를 숫자로 변환
//int transform(char* key)
//{
//	int number = 0;
//	while (*key)
//		number = 31 * number + *key++;    /// 무슨 원리인가요..
//	return number;
//}
//
//typedef struct {
//	char key[KEY_SIZE];  // 문자열
//	// 다른 필요한 필드들
//}element;
//



//// 제산 함수를 사용한 해싱 함수
//
//int hash_function(char* key) {
//	// 키를 자연수로 변환한 다음 테이블의 크기로 나누어 나머지를 반환
//	return transform(key) % TABLE_SIZE;
//}
//
////선형 조사법을 이용하여 테이블에 키를 삽입하고,
//// 테이블이 가득 찬 경우는 종료
//
//void hash_lp_add(element item, element ht[]) {
//	int i, hash_value;
//	hash_value = i = hash_function(item.key);
//	//printf("hash_address = %d\n",i);
//	while (!empty(ht[i])) {
//		if (equal(item, ht[i])) {
//			fprintf(stderr, "탐색키가 종료되었습니다.\n");  // i를 찾기 위한 작업
//			exit(1);
//		}
//		i = (i + 1) % TABLE_SIZE;
//		if (i == hash_value) {
//			fprintf(stderr, "테이블이 가득찼습니다\n");   // 1 cycle을 돈 것임
//			exit(1);
//		}
//	}
//	ht[i] = item;
//}
//
//// 선형조사법을 이용하여 테이블에 저장된 키를 탐색
//
//void hash_lp_search(element item, element ht[])
//{
//	int i, hash_value;
//	hash_value = i = hash_function(item.key);
//	while (!empty(ht[i]))
//	{
//		if (equal(item, ht[i])) {
//			fprintf(stderr, "탐색 %s: 위치 = %d\n", item.key, i);
//			return;
//		}
//		i = (i + 1) % TABLE_SIZE;
//		if (i == hash_value) {
//			fprintf(stderr, "찾는 값이 테이블에 없음\n"); // 1cycle을 다 돌았거나
//			return;
//		}
//	}
//	fprintf(stderr, "찾는 값이 테이블에 없음\n");  // 해시 테이블의 i 인덱스 범위를 초과하여 해시 테이블에 값이 없거나
//}
//
//
//// 해싱 테이블의 내용을 출력
//void hash_lp_print(element ht[])
//{
//	int i;
//	printf("\n===============================\n");
//	for (i = 0; i < TABLE_SIZE; i++)
//		printf("[%d] %s\n", i, ht[i].key);
//	printf("===============================\n\n");
//}
//// 해싱 테이블을 사용한 예제
//int main(void)
//{
//	char* s[7] = { "do", "for", "if", "case", "else", "return", "function" };
//	element e;
//	for (int i = 0; i < 7; i++) {
//		strcpy_s(e.key, sizeof(e.key), s[i]);
//		hash_lp_add(e, hash_table);
//		hash_lp_print(hash_table);
//	}
//	for (int i = 0; i < 7; i++) {
//		strcpy_s(e.key, sizeof(e.key),s[i]);
//		hash_lp_search(e, hash_table);
//	}
//	return 0;
//}


// 체이닝 법
#define SIZE 5

typedef struct {
	int key;
} element;

struct list {
	element item;
	struct list* link;
};

struct list* hash_table[TABLE_SIZE];

// 제산 함수를 사용한 해싱 함수
int hash_function(int key)
{
	return key % TABLE_SIZE;
}
// 체인법을 이용하여 테이블에 키를 삽입
void hash_chain_add(element item, struct list* ht[])
{
	int hash_value = hash_function(item.key);
	struct list* ptr;
	struct list* node_before = NULL, * node = ht[hash_value];
	for (; node; node_before = node, node = node->link) {
		if (node->item.key == item.key) {
			fprintf(stderr, "이미 탐색키가 저장되어 있음\n");
			return;
		}
	}
	ptr = (struct list*)malloc(sizeof(struct list));
	ptr->item = item;
	ptr->link = NULL;
	if (node_before)
		node_before->link = ptr;
	else
		ht[hash_value] = ptr;
}

// 체인법을 이용하여 테이블에 저장된 키를 탐색
void hash_chain_search(element item, struct list* ht[])
{
	struct list* node;

	int hash_value = hash_function(item.key);
	for (node = ht[hash_value]; node; node = node->link) {
		if (node->item.key == item.key) {
			fprintf(stderr, "탐색 %d 성공 \n", item.key);
			return;
		}
	}
	printf("키를 찾지 못했음\n");
}

// 해싱 테이블의 내용을 출력

void hash_chain_print(struct list* ht[])
{
	struct list* node;
	int i;
	printf("\n===============================\n");
	for (i = 0; i < TABLE_SIZE; i++) {
		printf("[%d]->", i);
		for (node = ht[i]; node; node = node->link) {
			printf("%d->", node->item.key);
		}
		printf("\n");
	}
	printf("===============================\n");
}


// 해싱 테이블을 사용한 예제 
int main(void)
{
	int data[SIZE] = { 8, 1, 9, 6, 13 };
	element e;

	for (int i = 0; i < SIZE; i++) {
		e.key = data[i];
		hash_chain_add(e, hash_table);
		
	}
	for (int i = 0; i < SIZE; i++) {
		e.key = data[i];
		hash_chain_search(e, hash_table);
		hash_chain_print(hash_table);
	}
	return 0;
}
